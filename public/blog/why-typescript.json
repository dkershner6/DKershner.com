{
  "templateKey": "BlogPostTemplate",
  "title": "Why TypeScript?",
  "date": "2020-01-19T20:31:45.757Z",
  "description": "An exploration into why someone would bother to use TypeScript over JavaScript",
  "featuredpost": false,
  "featuredimage": "/img/classic-car-1209334_1280.jpg",
  "tags": [
    "node",
    "react"
  ],
  "bodyContent": "# Downsides to Typescript\n\nBeing the Devil's advocate always seems like a good way to start.\n\n## I have to write more code to achieve the same result (Lower Productivity)\n\nThis is probably the #1 reason people give for arguing against TypeScript, and the argument is not without legitimacy. When compared to cleanly written JavaScript, TypeScript does require more code. Some of the code can be generated, or is fairly easy to write, but the point holds true. Instead of arguing, let's just look at some ways we can attack this issue.\n\n### VSCode Extensions\n\nYou and I are unlikely to be the first developer to encounter something repetitive in programming, and, being the helpful bunch we are, chances are even good someone has designed a tool to help. `Json2TS` is a great example of this. Copy JSON from anywhere, paste into VSCode with a special key combination as TypeScript interfaces.\n\n### VSCode itself (Intellisense)\n\nDesign yourself an interface, abstract class, and a class that inherits/extends both, then put your cursor on the class and voila, auto implemented fields and methods.\n\n![Implement TypeScript Interface](/img/implement_interface.jpg 'Implement TypeScript Interface')\n\nVSCode has many such shortcuts (including code snippets, try typing `ctor` inside a class), and can provide more help due to TypeScript providing more context as to what is likely needing to occur.\n\nOther editors obviously vary in their capabilities, and I do recognize that VSCode is the leader here.\n\n### Types save future time\n\nLastly, I will just touch on the prevention vs triage situation: If you define things in advance, you are more likely to be able to leverage that work as you build things around it. In short, every time you build and reference an object you have defined with a class or interface, you save having to remember exactly what it was named and what type of data you are dealing with. Types, in my experience, in all but the simplest of projects, save more time than they consume.\n\n## The code must compile\n\nThis downside is basically Node or Vanilla JS (does anyone still use JQuery?) only, as React and others also need to compile, but it is still worth touching on. The main issues this causes:\n\n-   Tests take longer to run.\n    -   This is 100% true, and I have not found a solution that solves this. The one upside is that with TypeScript I generally get less failing tests (and therefore less rounds of running tests).\n-   Additional configuration is necessary (tsconfig.json) / Larger package size for things like lambda, functions, or NPM.\n    -   This is also completely valid. The configuration is fairly simple, especially when compared to something like webpack and/or babel, but is still present.\n    -   This is likely the #1 sticking point for most companies as it generally requires help from DevOps to overcome (besides NPM, where you can just use `files`).\n\n## Additional probability of circular dependencies\n\nThis is actually not a common complaint, but one I encounter frequently enough to mention it here. This also exists in JavaScript, but in TypeScript you tend to be importing and exporting more items due to interfaces, and this can crop up if you place too many items in a single file (I encounter this frequently when using the Factory pattern, as that requires building an object while relying on another object).\n\nIf you encounter this error, it will be the following, very clear, JavaScript TypeErrors:\n\n```\nTypeError: Class extends value undefined is not a constructor or null.\n```\n\nOr\n\n```\nTypeError: Object prototype may only be an Object or null: undefined\n```\n\nClear as mud, eh?\n\nHere is the simplest possible example I can create to demonstrate this (including not typing data! The Horror!). It seems obvious with this simple of an example, but hopefully the implications in a larger application are apparent.\n\n```\n// venue.ts\nimport { VenueViews } from \"./venue_views\";\nexport class Venue {\n  setDataHere;\n\n  constructor(data) {\n    this.setDataHere = data;\n  }\n\n  main() {\n    const View = new VenueViews(this.setDataHere);\n  }\n}\n```\n\n```\n// venue_views.ts\nimport { Venue } from \"./venue\";\n\nexport class VenueViews extends Venue {\n  constructor(data) {\n    super(data);\n  }\n}\n```\n\n# Upsides to TypeScript\n\nAlright, enough with the issues, let's talk about how TypeScript's Pros **vastly** outweigh its Cons.\n\n## Understandability\n\nYes, that's a real word, and it's also the single most important attribute of any code written for all but the most temporary. I will let a few legendary authors help me convey this message better than I ever would.\n\n> \"Dynamic, highly parameterized software is harder to understand than more static software.\"\n>\n> _Gang of Four, Design Patterns: Elements of Reusable Object-Oriented Software_\n>\n> “Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...\\[Therefore,] making it easy to read makes it easier to write.”\n>\n> _Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_\n>\n> “Whenever I have to think to understand what the code is doing, I ask myself if I can refactor the code to make that understanding more immediately apparent.”\n>\n> _Martin Fowler, Refactoring: Improving the Design of Existing Code_\n\nTypeScript allows you to communicate significantly more information to the next developer who reads your code (which might be a confused, future you). This information will be used to spend less time reading and more time writing, increasing overall productivity. This self-documentation attribute of TypeScript can also be used to more easily generate other documentation, which can increase the likelihood of it being updated. That being said...\n\n> “Truth can only be found in one place: the code.”\n>\n> _Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_\n\n## Refactoring simplicity\n\nThe benefit of TypeScript's additional type information is no more readily apparent than when refactoring. TypeScript enables you to easily rename, move, or change data shapes without fear that you have missed one (or more) application(s) of the interface. This is not a replacement for testing, but it does speed the process along significantly.\n\n## Runtime errors can become compile time errors\n\n> This is not a replacement for testing\n>\n> _Myself, 3 seconds ago_\n\nTesting is still crucial, but they say an average of 15% of runtime errors would be caught by static typing. That's an additional 15% of protection from your users becoming guinea pigs.\n\n# Summary\n\nPros:\n\n-   Understandability AKA the most important aspect of programming.\n-   Refactoring speed.\n-   Potentially less runtime errors.\n\nCons:\n\n-   Compile step exists.\n-   Configuration exists.\n-   Circular dependencies may crop up.\n\nAll in all, I hope it is obvious that the pros vastly outweigh the cons in nearly every circumstance of Software Development.",
  "bodyHtml": "<h1>Downsides to Typescript</h1>\n<p>Being the Devil's advocate always seems like a good way to start.</p>\n<h2>I have to write more code to achieve the same result (Lower Productivity)</h2>\n<p>This is probably the #1 reason people give for arguing against TypeScript, and the argument is not without legitimacy. When compared to cleanly written JavaScript, TypeScript does require more code. Some of the code can be generated, or is fairly easy to write, but the point holds true. Instead of arguing, let's just look at some ways we can attack this issue.</p>\n<h3>VSCode Extensions</h3>\n<p>You and I are unlikely to be the first developer to encounter something repetitive in programming, and, being the helpful bunch we are, chances are even good someone has designed a tool to help. <code>Json2TS</code> is a great example of this. Copy JSON from anywhere, paste into VSCode with a special key combination as TypeScript interfaces.</p>\n<h3>VSCode itself (Intellisense)</h3>\n<p>Design yourself an interface, abstract class, and a class that inherits/extends both, then put your cursor on the class and voila, auto implemented fields and methods.</p>\n<p><img src=\"/img/implement_interface.jpg\" alt=\"Implement TypeScript Interface\" title=\"Implement TypeScript Interface\"></p>\n<p>VSCode has many such shortcuts (including code snippets, try typing <code>ctor</code> inside a class), and can provide more help due to TypeScript providing more context as to what is likely needing to occur.</p>\n<p>Other editors obviously vary in their capabilities, and I do recognize that VSCode is the leader here.</p>\n<h3>Types save future time</h3>\n<p>Lastly, I will just touch on the prevention vs triage situation: If you define things in advance, you are more likely to be able to leverage that work as you build things around it. In short, every time you build and reference an object you have defined with a class or interface, you save having to remember exactly what it was named and what type of data you are dealing with. Types, in my experience, in all but the simplest of projects, save more time than they consume.</p>\n<h2>The code must compile</h2>\n<p>This downside is basically Node or Vanilla JS (does anyone still use JQuery?) only, as React and others also need to compile, but it is still worth touching on. The main issues this causes:</p>\n<ul>\n<li>Tests take longer to run.\n<ul>\n<li>This is 100% true, and I have not found a solution that solves this. The one upside is that with TypeScript I generally get less failing tests (and therefore less rounds of running tests).</li>\n</ul>\n</li>\n<li>Additional configuration is necessary (tsconfig.json) / Larger package size for things like lambda, functions, or NPM.\n<ul>\n<li>This is also completely valid. The configuration is fairly simple, especially when compared to something like webpack and/or babel, but is still present.</li>\n<li>This is likely the #1 sticking point for most companies as it generally requires help from DevOps to overcome (besides NPM, where you can just use <code>files</code>).</li>\n</ul>\n</li>\n</ul>\n<h2>Additional probability of circular dependencies</h2>\n<p>This is actually not a common complaint, but one I encounter frequently enough to mention it here. This also exists in JavaScript, but in TypeScript you tend to be importing and exporting more items due to interfaces, and this can crop up if you place too many items in a single file (I encounter this frequently when using the Factory pattern, as that requires building an object while relying on another object).</p>\n<p>If you encounter this error, it will be the following, very clear, JavaScript TypeErrors:</p>\n<pre><code>TypeError: Class extends value undefined is not a constructor or null.\n</code></pre>\n<p>Or</p>\n<pre><code>TypeError: Object prototype may only be an Object or null: undefined\n</code></pre>\n<p>Clear as mud, eh?</p>\n<p>Here is the simplest possible example I can create to demonstrate this (including not typing data! The Horror!). It seems obvious with this simple of an example, but hopefully the implications in a larger application are apparent.</p>\n<pre><code>// venue.ts\nimport { VenueViews } from &quot;./venue_views&quot;;\nexport class Venue {\n  setDataHere;\n\n  constructor(data) {\n    this.setDataHere = data;\n  }\n\n  main() {\n    const View = new VenueViews(this.setDataHere);\n  }\n}\n</code></pre>\n<pre><code>// venue_views.ts\nimport { Venue } from &quot;./venue&quot;;\n\nexport class VenueViews extends Venue {\n  constructor(data) {\n    super(data);\n  }\n}\n</code></pre>\n<h1>Upsides to TypeScript</h1>\n<p>Alright, enough with the issues, let's talk about how TypeScript's Pros <strong>vastly</strong> outweigh its Cons.</p>\n<h2>Understandability</h2>\n<p>Yes, that's a real word, and it's also the single most important attribute of any code written for all but the most temporary. I will let a few legendary authors help me convey this message better than I ever would.</p>\n<blockquote>\n<p>&quot;Dynamic, highly parameterized software is harder to understand than more static software.&quot;</p>\n<p><em>Gang of Four, Design Patterns: Elements of Reusable Object-Oriented Software</em></p>\n<p>“Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write.”</p>\n<p><em>Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship</em></p>\n<p>“Whenever I have to think to understand what the code is doing, I ask myself if I can refactor the code to make that understanding more immediately apparent.”</p>\n<p><em>Martin Fowler, Refactoring: Improving the Design of Existing Code</em></p>\n</blockquote>\n<p>TypeScript allows you to communicate significantly more information to the next developer who reads your code (which might be a confused, future you). This information will be used to spend less time reading and more time writing, increasing overall productivity. This self-documentation attribute of TypeScript can also be used to more easily generate other documentation, which can increase the likelihood of it being updated. That being said...</p>\n<blockquote>\n<p>“Truth can only be found in one place: the code.”</p>\n<p><em>Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship</em></p>\n</blockquote>\n<h2>Refactoring simplicity</h2>\n<p>The benefit of TypeScript's additional type information is no more readily apparent than when refactoring. TypeScript enables you to easily rename, move, or change data shapes without fear that you have missed one (or more) application(s) of the interface. This is not a replacement for testing, but it does speed the process along significantly.</p>\n<h2>Runtime errors can become compile time errors</h2>\n<blockquote>\n<p>This is not a replacement for testing</p>\n<p><em>Myself, 3 seconds ago</em></p>\n</blockquote>\n<p>Testing is still crucial, but they say an average of 15% of runtime errors would be caught by static typing. That's an additional 15% of protection from your users becoming guinea pigs.</p>\n<h1>Summary</h1>\n<p>Pros:</p>\n<ul>\n<li>Understandability AKA the most important aspect of programming.</li>\n<li>Refactoring speed.</li>\n<li>Potentially less runtime errors.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Compile step exists.</li>\n<li>Configuration exists.</li>\n<li>Circular dependencies may crop up.</li>\n</ul>\n<p>All in all, I hope it is obvious that the pros vastly outweigh the cons in nearly every circumstance of Software Development.</p>\n",
  "preview": "Downsides to Typescript\n\nBeing the Devil's advocate always seems like a good way to start.\n\nI have to write",
  "dir": "public/blog",
  "base": "why-typescript.json",
  "ext": ".json",
  "sourceBase": "why-typescript.md",
  "sourceExt": ".md"
}