{
  "templateKey": "BlogPostTemplate",
  "title": "Azure Functions: Serilog Gotchas",
  "date": "2019-07-01T23:59:00.000Z",
  "description": "Serilog appears easy to use in Azure Functions, but apperances can be deceiving",
  "featuredpost": false,
  "featuredimage": "/img/logs.jpg",
  "tags": [
    "azure",
    "azureFunctions"
  ],
  "bodyContent": "# Some Background\n\nAzure Functions have great struggles when it comes to clients not being created statically. They note this in their docs very well, but on occasion you can do this in unknown fashion. The result, when it occurs, is very high connection or thread counts, which can lead to shutdowns as you approach [the limits](/blog/azure-functions-limits-how-to-overcome/).\n\n# Enter Serilog\n\nSerilog is very convenient, and one of the easiest ways to implement custom logging in Azure Functions. The recommended approaches to instantiate Serilog are typically:\n\n-   A global static variable - If you do this, you cannot use Azure Function's ILogger, and if you instantiate one per function, you will also hit limits.\n-   A (using) wrapper - If you do this, you will hit limits eventually (it takes a lot of concurrency).\n\n[Evan Dontje encountered the the first bullet point](https://evandontje.com/2018/10/09/high-thread-count-in-azure-functions/), and you can read about his experience there. I thought I was being savvy by doing it in a using clause, but after weeks of talks with Azure Support, I found out that I was just as bad off as he was.\n\n# Solution\n\nIn order to solve this issue, I used a combination of the two strategies, with a null check.\n\nAbove the function:\n\n```csharp\nprivate static Logger Log = null;\n```\n\nInside the function:\n\n```csharp\nif (Log == null)\n{\n  Log = CreateYourLoggerHere.Create();\n}\n```\n\nSimple, a little hacky, but it works. Don't spend the same time with Azure Support like I did.",
  "bodyHtml": "<h1>Some Background</h1>\n<p>Azure Functions have great struggles when it comes to clients not being created statically. They note this in their docs very well, but on occasion you can do this in unknown fashion. The result, when it occurs, is very high connection or thread counts, which can lead to shutdowns as you approach <a href=\"/blog/azure-functions-limits-how-to-overcome/\">the limits</a>.</p>\n<h1>Enter Serilog</h1>\n<p>Serilog is very convenient, and one of the easiest ways to implement custom logging in Azure Functions. The recommended approaches to instantiate Serilog are typically:</p>\n<ul>\n<li>A global static variable - If you do this, you cannot use Azure Function's ILogger, and if you instantiate one per function, you will also hit limits.</li>\n<li>A (using) wrapper - If you do this, you will hit limits eventually (it takes a lot of concurrency).</li>\n</ul>\n<p><a href=\"https://evandontje.com/2018/10/09/high-thread-count-in-azure-functions/\">Evan Dontje encountered the the first bullet point</a>, and you can read about his experience there. I thought I was being savvy by doing it in a using clause, but after weeks of talks with Azure Support, I found out that I was just as bad off as he was.</p>\n<h1>Solution</h1>\n<p>In order to solve this issue, I used a combination of the two strategies, with a null check.</p>\n<p>Above the function:</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Logger Log = <span class=\"hljs-literal\">null</span>;</code></pre><p>Inside the function:</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">if</span> (Log == <span class=\"hljs-literal\">null</span>)\n{\n  Log = CreateYourLoggerHere.Create();\n}</code></pre><p>Simple, a little hacky, but it works. Don't spend the same time with Azure Support like I did.</p>\n",
  "preview": "Some Background\n\nAzure Functions have great struggles when it comes to clients not being created statically.",
  "dir": "public/blog",
  "base": "azure-functions-serilog-gotchas.json",
  "ext": ".json",
  "sourceBase": "azure-functions-serilog-gotchas.md",
  "sourceExt": ".md"
}